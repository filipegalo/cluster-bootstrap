{{- if .Values.vaultSeed.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-seed-repo-ssh-key
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-wave: "10"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  backoffLimit: 5
  template:
    metadata:
      labels:
        app: vault-seed
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      containers:
        - name: vault-seed
          image: hashicorp/vault:1.15.4
          env:
            - name: VAULT_ADDR
              value: "http://vault.{{ .Release.Namespace }}.svc:8200"
            - name: VAULT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: vault-root-token
                  key: token
                  optional: true
            - name: VAULT_AUTO_UNSEAL_TOKEN
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.vaultAutoUnseal.secretName | default "vault-unseal-keys" }}
                  key: root-token
                  optional: true
          command:
            - /bin/sh
            - -ec
            - |
              # Wait for Vault to be ready
              echo "Waiting for Vault to be ready..."
              until vault status 2>/dev/null; do
                echo "Vault not ready, retrying in 5s..."
                sleep 5
              done

              # Resolve root token: explicit > auto-unseal > dev default
              if [ -z "$VAULT_TOKEN" ] && [ -n "$VAULT_AUTO_UNSEAL_TOKEN" ]; then
                export VAULT_TOKEN="$VAULT_AUTO_UNSEAL_TOKEN"
              elif [ -z "$VAULT_TOKEN" ]; then
                export VAULT_TOKEN="root"
              fi

              # Enable KV v2 secrets engine (ignore if already enabled)
              vault secrets enable -path=secret kv-v2 2>/dev/null || echo "KV v2 already enabled"

              # Check if the secret already exists in Vault
              if vault kv get secret/{{ .Values.vaultSeed.vaultSecretPath }} >/dev/null 2>&1; then
                echo "Secret secret/{{ .Values.vaultSeed.vaultSecretPath }} already exists in Vault, skipping."
                exit 0
              fi

              # Read the SSH private key from the Kubernetes secret via the API
              echo "Reading repo-ssh-key from namespace {{ .Values.vaultSeed.secretNamespace }}..."
              KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              SSH_KEY=$(wget -qO- \
                --header "Authorization: Bearer ${KUBE_TOKEN}" \
                "https://kubernetes.default.svc/api/v1/namespaces/{{ .Values.vaultSeed.secretNamespace }}/secrets/{{ .Values.vaultSeed.secretName }}" \
                --no-check-certificate | \
                sed -n 's/.*"{{ .Values.vaultSeed.secretKey }}"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | \
                base64 -d)

              if [ -z "$SSH_KEY" ]; then
                echo "ERROR: Failed to read SSH key from secret {{ .Values.vaultSeed.secretNamespace }}/{{ .Values.vaultSeed.secretName }}"
                exit 1
              fi

              # Write to Vault
              echo "Seeding secret/{{ .Values.vaultSeed.vaultSecretPath }}..."
              vault kv put secret/{{ .Values.vaultSeed.vaultSecretPath }} \
                sshPrivateKey="$SSH_KEY"

              echo "Vault secret seeded successfully!"
{{- end }}

{{- if .Values.vaultAutoUnseal.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-auto-unseal
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "0"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  backoffLimit: 5
  template:
    metadata:
      labels:
        app: vault-auto-unseal
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      containers:
        - name: vault-auto-unseal
          image: bitnami/kubectl:latest
          env:
            - name: VAULT_ADDR
              value: "http://vault.{{ .Release.Namespace }}.svc:8200"
            - name: SECRET_NAME
              value: {{ .Values.vaultAutoUnseal.secretName | quote }}
            - name: NAMESPACE
              value: {{ .Release.Namespace }}
            - name: KEY_SHARES
              value: {{ .Values.vaultAutoUnseal.keyShares | quote }}
            - name: KEY_THRESHOLD
              value: {{ .Values.vaultAutoUnseal.keyThreshold | quote }}
            - name: VAULT_POD
              value: "vault-0"
          command:
            - /bin/sh
            - -ec
            - |
              # Helper: run vault commands via kubectl exec
              vexec() {
                kubectl exec -n "${NAMESPACE}" "${VAULT_POD}" -- \
                  env VAULT_ADDR=http://127.0.0.1:8200 vault "$@"
              }

              # Wait for vault-0 pod to be running (not Ready — it won't be ready until unsealed)
              echo "Waiting for ${VAULT_POD} to be running..."
              while true; do
                PHASE=$(kubectl get pod -n "${NAMESPACE}" "${VAULT_POD}" -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
                if [ "$PHASE" = "Running" ]; then
                  break
                fi
                echo "Pod phase: ${PHASE:-not found}, retrying in 5s..."
                sleep 5
              done

              # Wait for Vault to respond (sealed or uninitialized counts as responding)
              echo "Waiting for Vault to be reachable..."
              while true; do
                rc=0
                vexec status -format=json >/dev/null 2>&1 || rc=$?
                # 0 = unsealed, 2 = sealed/uninitialized but reachable
                if [ "$rc" -eq 0 ] || [ "$rc" -eq 2 ]; then
                  break
                fi
                echo "Vault not reachable (rc=$rc), retrying in 5s..."
                sleep 5
              done

              # Get vault status — capture output even on non-zero exit
              STATUS=$(vexec status -format=json 2>&1 || true)
              echo "Raw status: ${STATUS}"

              # Parse JSON — handle both with and without spaces around colons
              INITIALIZED=$(echo "$STATUS" | sed -n 's/.*"initialized" *: *\(true\|false\).*/\1/p')
              SEALED=$(echo "$STATUS" | sed -n 's/.*"sealed" *: *\(true\|false\).*/\1/p')

              # Fallback: if parsing failed, check exit code directly
              if [ -z "$INITIALIZED" ]; then
                rc=0
                vexec status >/dev/null 2>&1 || rc=$?
                if [ "$rc" -eq 2 ]; then
                  # Could be sealed or uninitialized — try init to find out
                  INITIALIZED="false"
                  SEALED="true"
                elif [ "$rc" -eq 0 ]; then
                  INITIALIZED="true"
                  SEALED="false"
                fi
              fi

              echo "Vault status: initialized=${INITIALIZED}, sealed=${SEALED}"

              # Check if unseal keys secret already exists
              HAS_SECRET="false"
              if kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" >/dev/null 2>&1; then
                HAS_SECRET="true"
              fi

              # --- INIT if needed ---
              if [ "$INITIALIZED" = "false" ]; then
                echo "Vault is not initialized. Initializing with ${KEY_SHARES} shares, threshold ${KEY_THRESHOLD}..."
                INIT_OUTPUT=$(vexec operator init \
                  -key-shares="${KEY_SHARES}" \
                  -key-threshold="${KEY_THRESHOLD}" \
                  -format=json)

                echo "Init output: ${INIT_OUTPUT}"
                ROOT_TOKEN=$(echo "$INIT_OUTPUT" | sed -n 's/.*"root_token" *: *"\([^"]*\)".*/\1/p')
                echo "Root token extracted: ${ROOT_TOKEN}"

                # Extract unseal keys from JSON array — one per line
                UNSEAL_KEYS=$(echo "$INIT_OUTPUT" | sed -n '/"unseal_keys_b64"/,/]/p' | grep '"' | tr -d ' ",')
                echo "Unseal keys extracted: ${UNSEAL_KEYS}"

                # Build kubectl create secret command
                SECRET_ARGS="--from-literal=root-token=${ROOT_TOKEN}"
                i=0
                for KEY in ${UNSEAL_KEYS}; do
                  SECRET_ARGS="${SECRET_ARGS} --from-literal=unseal-key-${i}=${KEY}"
                  i=$((i+1))
                done

                if [ "$HAS_SECRET" = "true" ]; then
                  echo "Deleting old secret ${SECRET_NAME}..."
                  kubectl delete secret -n "${NAMESPACE}" "${SECRET_NAME}"
                fi

                echo "Creating K8s secret ${SECRET_NAME}..."
                eval kubectl create secret generic "${SECRET_NAME}" -n "${NAMESPACE}" ${SECRET_ARGS}

                echo "Vault initialized. Keys stored in secret ${NAMESPACE}/${SECRET_NAME}."
                SEALED="true"
                HAS_SECRET="true"
              fi

              # --- UNSEAL if needed ---
              if [ "$SEALED" = "true" ]; then
                echo "Vault is sealed. Unsealing..."

                if [ "$HAS_SECRET" = "false" ]; then
                  echo "ERROR: Vault is sealed but no unseal keys found in secret ${NAMESPACE}/${SECRET_NAME}."
                  echo "Please unseal Vault manually or delete the Vault PVC and re-deploy."
                  exit 1
                fi

                i=0
                while [ $i -lt ${KEY_THRESHOLD} ]; do
                  KEY=$(kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" -o jsonpath="{.data.unseal-key-${i}}" | base64 -d)
                  echo "Applying unseal key $((i+1))/${KEY_THRESHOLD}..."
                  kubectl exec -n "${NAMESPACE}" "${VAULT_POD}" -- \
                    sh -c "VAULT_ADDR=http://127.0.0.1:8200 vault operator unseal ${KEY}"
                  i=$((i+1))
                done

                echo "vault-0 unsealed successfully."
              else
                echo "Vault is already unsealed."
              fi

              # --- Store root token in vault-root-token secret for other Jobs ---
              ROOT_TOKEN=$(kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" -o jsonpath="{.data.root-token}" 2>/dev/null | base64 -d 2>/dev/null || echo "")
              if [ -n "$ROOT_TOKEN" ]; then
                if kubectl get secret -n "${NAMESPACE}" vault-root-token >/dev/null 2>&1; then
                  kubectl patch secret -n "${NAMESPACE}" vault-root-token \
                    -p "{\"stringData\":{\"token\":\"${ROOT_TOKEN}\"}}"
                  echo "Updated vault-root-token secret."
                else
                  kubectl create secret generic vault-root-token -n "${NAMESPACE}" \
                    --from-literal=token="${ROOT_TOKEN}"
                  echo "Created vault-root-token secret."
                fi
              fi

              echo "Vault auto-unseal complete!"
{{- end }}

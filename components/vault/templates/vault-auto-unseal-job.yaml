{{- if .Values.vaultAutoUnseal.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-auto-unseal
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-wave: "-10"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  backoffLimit: 5
  template:
    metadata:
      labels:
        app: vault-auto-unseal
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      containers:
        - name: vault-auto-unseal
          image: hashicorp/vault:1.15.4
          env:
            - name: VAULT_ADDR
              value: "http://vault-0.vault-internal.{{ .Release.Namespace }}.svc:8200"
            - name: SECRET_NAME
              value: {{ .Values.vaultAutoUnseal.secretName | quote }}
            - name: NAMESPACE
              value: {{ .Release.Namespace }}
            - name: KEY_SHARES
              value: {{ .Values.vaultAutoUnseal.keyShares | quote }}
            - name: KEY_THRESHOLD
              value: {{ .Values.vaultAutoUnseal.keyThreshold | quote }}
            {{- if .Values.vault.server.ha.enabled }}
            - name: HA_REPLICAS
              value: {{ .Values.vault.server.ha.replicas | quote }}
            {{- else }}
            - name: HA_REPLICAS
              value: "1"
            {{- end }}
          command:
            - /bin/sh
            - -ec
            - |
              KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              KUBE_API="https://kubernetes.default.svc"
              CACERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

              kube_get() {
                wget -qO- --ca-certificate="$CACERT" \
                  --header "Authorization: Bearer ${KUBE_TOKEN}" \
                  "${KUBE_API}${1}"
              }

              kube_put() {
                wget -qO- --ca-certificate="$CACERT" \
                  --header "Authorization: Bearer ${KUBE_TOKEN}" \
                  --header "Content-Type: application/json" \
                  --method=PUT \
                  --body-data="$2" \
                  "${KUBE_API}${1}" 2>/dev/null || true
              }

              kube_post() {
                wget -qO- --ca-certificate="$CACERT" \
                  --header "Authorization: Bearer ${KUBE_TOKEN}" \
                  --header "Content-Type: application/json" \
                  --method=POST \
                  --body-data="$2" \
                  "${KUBE_API}${1}" 2>/dev/null || true
              }

              # Wait for vault-0 to respond (may be sealed or uninitialized, but must be reachable)
              # vault status exits: 0=unsealed, 1=error, 2=sealed/uninitialized
              # We accept any response (exit 0 or 2) as "reachable"
              echo "Waiting for Vault to be reachable..."
              while true; do
                rc=0
                STATUS=$(vault status -format=json 2>/dev/null) || rc=$?
                if [ "$rc" -eq 0 ] || [ "$rc" -eq 2 ]; then
                  break
                fi
                echo "Vault not reachable (rc=$rc), retrying in 5s..."
                sleep 5
              done
              INITIALIZED=$(echo "$STATUS" | sed -n 's/.*"initialized"[[:space:]]*:[[:space:]]*\(true\|false\).*/\1/p')
              SEALED=$(echo "$STATUS" | sed -n 's/.*"sealed"[[:space:]]*:[[:space:]]*\(true\|false\).*/\1/p')

              # Check if unseal keys secret already exists
              EXISTING_SECRET=$(kube_get "/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" 2>/dev/null || echo "")
              HAS_SECRET="false"
              if echo "$EXISTING_SECRET" | grep -q '"kind":"Secret"'; then
                HAS_SECRET="true"
              fi

              # --- INIT if needed ---
              if [ "$INITIALIZED" = "false" ]; then
                echo "Vault is not initialized. Initializing with ${KEY_SHARES} shares, threshold ${KEY_THRESHOLD}..."
                INIT_OUTPUT=$(vault operator init \
                  -key-shares=${KEY_SHARES} \
                  -key-threshold=${KEY_THRESHOLD} \
                  -format=json)

                ROOT_TOKEN=$(echo "$INIT_OUTPUT" | sed -n 's/.*"root_token"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')

                # Build JSON for the K8s secret with base64-encoded values
                # Extract unseal keys
                KEYS_JSON=""
                i=0
                while [ $i -lt ${KEY_SHARES} ]; do
                  KEY=$(echo "$INIT_OUTPUT" | sed -n 's/.*"unseal_keys_b64"[[:space:]]*:[[:space:]]*\[//p' | tr ',' '\n' | tr -d '[] "' | sed -n "$((i+1))p")
                  KEY_B64=$(echo -n "$KEY" | base64 | tr -d '\n')
                  if [ -n "$KEYS_JSON" ]; then KEYS_JSON="${KEYS_JSON},"; fi
                  KEYS_JSON="${KEYS_JSON}\"unseal-key-${i}\":\"${KEY_B64}\""
                  i=$((i+1))
                done
                ROOT_TOKEN_B64=$(echo -n "$ROOT_TOKEN" | base64 | tr -d '\n')

                SECRET_BODY="{\"apiVersion\":\"v1\",\"kind\":\"Secret\",\"metadata\":{\"name\":\"${SECRET_NAME}\",\"namespace\":\"${NAMESPACE}\"},\"data\":{${KEYS_JSON},\"root-token\":\"${ROOT_TOKEN_B64}\"}}"

                if [ "$HAS_SECRET" = "true" ]; then
                  echo "Updating existing K8s secret ${SECRET_NAME}..."
                  kube_put "/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" "$SECRET_BODY"
                else
                  echo "Creating K8s secret ${SECRET_NAME}..."
                  kube_post "/api/v1/namespaces/${NAMESPACE}/secrets" "$SECRET_BODY"
                fi

                echo "Vault initialized. Keys stored in secret ${NAMESPACE}/${SECRET_NAME}."
                SEALED="true"
              fi

              # --- UNSEAL if needed ---
              if [ "$SEALED" = "true" ]; then
                echo "Vault is sealed. Unsealing..."

                if [ "$HAS_SECRET" = "false" ] && [ "$INITIALIZED" != "false" ]; then
                  # Re-check in case we just created it above
                  EXISTING_SECRET=$(kube_get "/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" 2>/dev/null || echo "")
                  if ! echo "$EXISTING_SECRET" | grep -q '"kind":"Secret"'; then
                    echo "ERROR: Vault is sealed but no unseal keys found in secret ${NAMESPACE}/${SECRET_NAME}."
                    echo "Please unseal Vault manually."
                    exit 1
                  fi
                fi

                i=0
                while [ $i -lt ${KEY_THRESHOLD} ]; do
                  KEY_B64=$(echo "$EXISTING_SECRET" | sed -n "s/.*\"unseal-key-${i}\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p")
                  if [ -z "$KEY_B64" ]; then
                    # Re-fetch secret (may have been created during init above)
                    EXISTING_SECRET=$(kube_get "/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}")
                    KEY_B64=$(echo "$EXISTING_SECRET" | sed -n "s/.*\"unseal-key-${i}\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p")
                  fi
                  KEY=$(echo "$KEY_B64" | base64 -d)
                  echo "Applying unseal key $((i+1))/${KEY_THRESHOLD}..."
                  vault operator unseal "$KEY"
                  i=$((i+1))
                done

                echo "vault-0 unsealed successfully."
              else
                echo "Vault is already unsealed."
              fi

              # --- UNSEAL HA replicas if needed ---
              if [ "${HA_REPLICAS}" -gt 1 ]; then
                # Re-fetch keys if needed
                if [ -z "$EXISTING_SECRET" ] || ! echo "$EXISTING_SECRET" | grep -q '"kind":"Secret"'; then
                  EXISTING_SECRET=$(kube_get "/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}")
                fi

                r=1
                while [ $r -lt ${HA_REPLICAS} ]; do
                  REPLICA_ADDR="http://vault-${r}.vault-internal.${NAMESPACE}.svc:8200"
                  echo "Checking vault-${r}..."

                  # Wait for replica to be reachable
                  RETRY=0
                  REPLICA_REACHABLE="false"
                  while true; do
                    rc=0
                    REPLICA_STATUS=$(VAULT_ADDR="$REPLICA_ADDR" vault status -format=json 2>/dev/null) || rc=$?
                    if [ "$rc" -eq 0 ] || [ "$rc" -eq 2 ]; then
                      REPLICA_REACHABLE="true"
                      break
                    fi
                    RETRY=$((RETRY+1))
                    if [ $RETRY -gt 30 ]; then
                      echo "WARNING: vault-${r} not reachable after 150s, skipping."
                      break
                    fi
                    sleep 5
                  done

                  if [ "$REPLICA_REACHABLE" = "false" ]; then
                    r=$((r+1))
                    continue
                  fi
                  REPLICA_SEALED=$(echo "$REPLICA_STATUS" | sed -n 's/.*"sealed"[[:space:]]*:[[:space:]]*\(true\|false\).*/\1/p')

                  if [ "$REPLICA_SEALED" = "true" ]; then
                    echo "Unsealing vault-${r}..."
                    j=0
                    while [ $j -lt ${KEY_THRESHOLD} ]; do
                      KEY_B64=$(echo "$EXISTING_SECRET" | sed -n "s/.*\"unseal-key-${j}\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p")
                      KEY=$(echo "$KEY_B64" | base64 -d)
                      VAULT_ADDR="$REPLICA_ADDR" vault operator unseal "$KEY"
                      j=$((j+1))
                    done
                    echo "vault-${r} unsealed."
                  else
                    echo "vault-${r} is already unsealed."
                  fi

                  r=$((r+1))
                done
              fi

              echo "Vault auto-unseal complete!"
{{- end }}
